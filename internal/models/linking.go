// Code generated by GoGM 2.1.1. DO NOT EDIT
package models

import (
	"errors"
)

// LinkToPersonOnFieldParents links Person to Person on the fields Person.Parents and Person.Children.
// note this uses the special edge ParentOf
func (l *Person) LinkToPersonOnFieldParents(target *Person, edge *ParentOf) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if edge == nil {
		return errors.New("edge can not be nil")
	}

	err := edge.SetStartNode(target)
	if err != nil {
		return err
	}

	err = edge.SetEndNode(l)
	if err != nil {
		return err
	}

	if l.Parents == nil {
		l.Parents = make([]*ParentOf, 1)
		l.Parents[0] = edge
	} else {
		l.Parents = append(l.Parents, edge)
	}

	if target.Children == nil {
		target.Children = make([]*ParentOf, 1)
		target.Children[0] = edge
	} else {
		target.Children = append(target.Children, edge)
	}

	return nil
}

// UnlinkFromPersonOnFieldParents unlinks Person from Person on the fields Person.Parents and Person.Children.
// also note this uses the special edge ParentOf
func (l *Person) UnlinkFromPersonOnFieldParents(target *Person) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if l.Parents != nil {
		for i, unlinkTarget := range l.Parents {

			obj := unlinkTarget.GetStartNode()

			checkObj, ok := obj.(*Person)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Person]")
			}
			if checkObj.UUID == target.UUID {
				a := &l.Parents
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	if target.Children != nil {
		for i, unlinkTarget := range target.Children {

			obj := unlinkTarget.GetEndNode()

			checkObj, ok := obj.(*Person)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Person]")
			}
			if checkObj.UUID == l.UUID {
				a := &target.Children
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToPersonOnFieldChildren links Person to Person on the fields Person.Children and Person.Parents.
// note this uses the special edge ParentOf
func (l *Person) LinkToPersonOnFieldChildren(target *Person, edge *ParentOf) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if edge == nil {
		return errors.New("edge can not be nil")
	}

	err := edge.SetStartNode(l)
	if err != nil {
		return err
	}

	err = edge.SetEndNode(target)
	if err != nil {
		return err
	}

	if l.Children == nil {
		l.Children = make([]*ParentOf, 1)
		l.Children[0] = edge
	} else {
		l.Children = append(l.Children, edge)
	}

	if target.Parents == nil {
		target.Parents = make([]*ParentOf, 1)
		target.Parents[0] = edge
	} else {
		target.Parents = append(target.Parents, edge)
	}

	return nil
}

// UnlinkFromPersonOnFieldChildren unlinks Person from Person on the fields Person.Children and Person.Parents.
// also note this uses the special edge ParentOf
func (l *Person) UnlinkFromPersonOnFieldChildren(target *Person) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if l.Children != nil {
		for i, unlinkTarget := range l.Children {

			obj := unlinkTarget.GetEndNode()

			checkObj, ok := obj.(*Person)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Person]")
			}
			if checkObj.UUID == target.UUID {
				a := &l.Children
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	if target.Parents != nil {
		for i, unlinkTarget := range target.Parents {

			obj := unlinkTarget.GetStartNode()

			checkObj, ok := obj.(*Person)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Person]")
			}
			if checkObj.UUID == l.UUID {
				a := &target.Parents
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}
